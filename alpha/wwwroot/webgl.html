<!DOCTYPE html>
<html>
<head>
    <title>PixiJS Simulation</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="pixi-container"></div>

    <!-- 1. PixiJS 라이브러리 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.14.0/dist/pixi.min.js"></script>
    
    <!-- 2. 우리가 만든 PixiManager 로드 -->
    <script src="./js/pixiManager.js"></script>

    <!-- 3. 메인 애플리케이션 로직 (type="module") -->
    <script type="module">
        // ======================================================================
        // ===                       ★★★ 수정된 부분 ★★★                       ===
        // ======================================================================
        // 필요한 부품들(Tween, Easing, update)을 각각 이름으로 직접 import 합니다.
        import { Tween, Easing, update as updateTweens } from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@20.0.3/dist/tween.esm.js';
        // ======================================================================

        window.onload = async () => {
            const container = document.getElementById('pixi-container');
            const pixiManager = new PixiManager(container);

            // 로딩 대기
            await new Promise(resolve => {
                const checkReady = () => {
                    if (pixiManager.app && pixiManager.textures.trees.length > 0) resolve();
                    else setTimeout(checkReady, 100);
                };
                checkReady();
            });

            // --- 모든 엔티티를 담을 배열 ---
            const allEntities = [];
            const animals = [];

            // ... (나무, 잡초 생성 코드는 변경 없음) ...
            const bigTree = pixiManager.createTree(8);
            bigTree.x = pixiManager.app.screen.width * 0.7;
            bigTree.y = pixiManager.app.screen.height * 0.5;
            allEntities.push(bigTree);
            const grassCount = 50;
            for (let i = 0; i < grassCount; i++) {
                const grass = pixiManager.createGrass(Math.floor(Math.random() * 17));
                grass.x = Math.random() * pixiManager.app.screen.width;
                grass.y = Math.random() * pixiManager.app.screen.height;
                grass.scale.set(0.1);
            }

            // ... (동물 생성 코드는 변경 없음) ...
            for (let i = 0; i < 10; i++) {
                const rabbit = pixiManager.createAnimal('rabbit', 'idle');
                rabbit.x = Math.random() * pixiManager.app.screen.width;
                rabbit.y = Math.random() * pixiManager.app.screen.height;
                allEntities.push(rabbit);
                animals.push(rabbit);
            }
            const wolf = pixiManager.createAnimal('wolf', 'idle');
            wolf.x = pixiManager.app.screen.width * 0.2;
            wolf.y = pixiManager.app.screen.height * 0.8;
            allEntities.push(wolf);
            animals.push(wolf);

            // --- AI 및 이동 함수 (moveTo 함수 수정됨) ---
            function moveTo(character, target, duration) {
                // ==========================================================
                // ===             ★★★ 좌우 반전 로직 추가 ★★★           ===
                // ==========================================================
                // 목표 지점의 x좌표와 현재 x좌표를 비교하여 방향을 결정합니다.
                if (target.x > character.x) {
                    // 목표가 오른쪽에 있으므로, 오른쪽을 보도록 캐릭터를 좌우 반전시킵니다.
                    character.scale.x = -1; 
                } else if (target.x < character.x) {
                    // 목표가 왼쪽에 있으므로, 왼쪽을 보도록 원래 방향으로 되돌립니다.
                    character.scale.x = 1;
                }
                // (만약 target.x와 character.x가 같다면, 현재 방향을 유지합니다.)
                // ==========================================================

                character.textures = character.animations.run;
                character.play();

                new Tween(character.position)
                    .to(target, duration * 1000)
                    .easing(Easing.Quadratic.InOut) // 이 부분은 원하시는 Easing으로 변경 가능
                    .onComplete(() => {
                        character.textures = character.animations.idle;
                        character.play();
                        setTimeout(() => thinkAndAct(character), 1000 + Math.random() * 3000);
                    })
                    .start();
            }
            
            function thinkAndAct(character) { /* ... (내부 로직 변경 없음) ... */ 
                const screen = pixiManager.app.screen;
                const target = { x: Math.random() * screen.width, y: Math.random() * screen.height };
                const dx = target.x - character.x;
                const dy = target.y - character.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const baseSpeed = 150;
                const duration = distance / baseSpeed;
                character.animationSpeed = 0.2 + (distance / 2000);
                moveTo(character, target, duration);
            }

            animals.forEach(animal => thinkAndAct(animal));

            // --- 메인 게임 루프 (수정됨) ---
            pixiManager.app.ticker.add((ticker) => {
                // 1. Tween.js 업데이트 (모든 객체의 x, y 위치를 변경)
                updateTweens();

                // 2. 현재 이동 속도에 기반한 애니메이션 속도 조절
                for (const animal of animals) {
                    // 이전 프레임의 위치가 없으면 현재 위치를 저장하고 건너뜀
                    if (animal.lastX === undefined) {
                        animal.lastX = animal.x;
                        animal.lastY = animal.y;
                        continue;
                    }

                    // 이번 프레임에 이동한 거리 계산
                    const dx = animal.x - animal.lastX;
                    const dy = animal.y - animal.lastY;
                    const distanceMoved = Math.sqrt(dx * dx + dy * dy);

                    // 현재 속도 (프레임당 이동 픽셀)
                    const currentSpeed = distanceMoved / ticker.deltaTime;
                    
                    if (distanceMoved > 0.1) { // 아주 조금이라도 움직였을 때만
                        // 기본 속도 + 현재 속도에 비례한 추가 속도
                        const baseAnimationSpeed = 0.1;
                        const speedMultiplier = 0.2; // 이 값을 조절해 민감도 변경
                        animal.animationSpeed = baseAnimationSpeed + currentSpeed * speedMultiplier;
                    }

                    // 다음 프레임 계산을 위해 현재 위치를 '이전 위치'로 저장
                    animal.lastX = animal.x;
                    animal.lastY = animal.y;
                }

                // 3. Y-Sorting (변경 없음)
                for (const child of pixiManager.grassLayer.children) { child.zIndex = child.y; }
                for (const child of pixiManager.entityLayer.children) {
                    child.zIndex = child.y;
                    if (child.shadow) {
                        child.shadow.x = child.x;
                        child.shadow.y = child.y + (child.shadowOffsetY || 0);
                        child.shadow.zIndex = child.y;
                        const objectWidth = child.texture.width * Math.abs(child.scale.x);
                        child.shadow.width = objectWidth * (child.shadowWidthRatio || 0.8);
                        child.shadow.height = objectWidth * 0.2;
                    }
                }
            });
        };
    </script>
</body>
</html>