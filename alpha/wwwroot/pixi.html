<!DOCTYPE html>
<html>
<head>
    <title>PixiJS Simulation</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="pixi-container"></div>

    <!-- 1. PixiJS 라이브러리 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.14.0/dist/pixi.min.js"></script>
    
    <!-- 2. 우리가 만든 PixiManager 로드 -->
    <script src="./js/pixiManager.js?1"></script>

    <!-- 3. 메인 애플리케이션 로직 -->
    <script>
        window.onload = async () => {
            const container = document.getElementById('pixi-container');
            
            // PixiManager 인스턴스 생성 (이때 초기화 및 에셋 로딩이 시작됩니다)
            const pixiManager = new PixiManager(container);

            // 로딩이 완료될 때까지 기다려야 합니다.
            // PixiManager가 준비되었는지 확인하는 간단한 폴링 방법
            await new Promise(resolve => {
                const checkReady = () => {
                    if (pixiManager.app && pixiManager.textures.trees.length > 0) {
                        resolve();
                    } else {
                        setTimeout(checkReady, 100);
                    }
                };
                checkReady();
            });

            // --- 이제 PixiManager를 마음껏 사용할 수 있습니다! ---

            // --- 모든 엔티티를 담을 배열 ---
            const allEntities = [];

            // 예시 1: 다 자란 나무 생성
            const bigTree = pixiManager.createTree(8);
            bigTree.x = pixiManager.app.screen.width / 2;
            bigTree.y = 699;
            allEntities.push(bigTree); // 배열에 추가

            // ==========================================================
            // ===               잡초 생성 코드 추가                  ===
            // ==========================================================
            const grassCount = 50; // 원하는 잡초 개수를 설정합니다.
            const totalGrassStages = 17; // pixiManager에 설정된 잡초의 총 스테이지 수

            for (let i = 0; i < grassCount; i++) {
                // 0부터 16까지의 잡초 스테이지 중 하나를 무작위로 선택합니다.
                const randomStage = Math.floor(Math.random() * totalGrassStages);
                const grass = pixiManager.createGrass(randomStage);

                // 화면 내 무작위 위치에 배치합니다.
                grass.x = Math.random() * pixiManager.app.screen.width;
                grass.y = Math.random() * pixiManager.app.screen.height;

                // 크기를 살짝씩 다르게 하여 더 자연스럽게 만듭니다.
                // const randomScale = 0.8 + Math.random() * 0.4; // 80% ~ 120% 크기
                grass.scale.set(0.1);
            }
            // ==========================================================


            // 1. 모든 토끼를 담을 빈 배열을 생성합니다.
            const allRabbits = [];

            // 예시 2: 토끼 10마리 생성
            for (let i = 0; i < 10; i++) {
                const rabbit = pixiManager.createAnimal('rabbit', 'run');
                rabbit.x = Math.random() * pixiManager.app.screen.width;
                rabbit.y = Math.random() * pixiManager.app.screen.height;
                rabbit.animationSpeed = 0.2 + Math.random() * 0.5; // 속도도 살짝 다르게

                // 이동 방향과 속도를 각 토끼 객체에 저장합니다.
                const direction = Math.random() < 0.5 ? 1 : -1; // 1: 오른쪽, -1: 왼쪽
                rabbit.scale.x = direction * -1; // 기본이 왼쪽을 보니, 오른쪽(+1)일 때 뒤집음(-1)
                rabbit.vx = direction * rabbit.animationSpeed * 2; // 이동 속도

                allEntities.push(rabbit); // 배열에 추가
            }

            // 예시 3: 늑대 생성 및 애니메이션 전환
            const wolf = pixiManager.createAnimal('wolf', 'idle');
            wolf.x = 600;
            wolf.y = 900;
            allEntities.push(wolf); // 배열에 추가
            
            // 3초 후 늑대 애니메이션을 'howl'로 변경
            setTimeout(() => {
                wolf.textures = wolf.animations.howl;
                wolf.play();
            }, 3000);

            // 메인 게임 루프 (Y-Sorting 및 객체 이동)
            pixiManager.app.ticker.add((ticker) => {
                // --- 모든 엔티티를 하나의 루프에서 처리 ---
                for (const entity of allEntities) {
                    // 움직이는 객체만 위치 업데이트 (vx 속성이 있는 경우)
                    if (entity.vx) {
                        entity.x += entity.vx * ticker.deltaTime;
                        if (entity.vx > 0 && entity.x > pixiManager.app.screen.width + 50) {
                            entity.x = -50;
                        } else if (entity.vx < 0 && entity.x < -50) {
                            entity.x = pixiManager.app.screen.width + 50;
                        }
                    }
                }

                // --- Y-Sorting (이제 모든 레이어를 한번에 처리) ---
                for (const child of pixiManager.grassLayer.children) {
                    child.zIndex = child.y;
                }
                for (const child of pixiManager.entityLayer.children) {
                    child.zIndex = child.y;
                    if (child.shadow) {
                        child.shadow.x = child.x;
                        child.shadow.y = child.y + (child.shadowOffsetY || 0);
                        child.shadow.zIndex = child.y;
                        
                        // 객체의 실제 가로 크기에 비례해서 그림자 크기 설정
                        const objectWidth = child.width;
                        child.shadow.width = objectWidth * (child.shadowWidthRatio || 0.8);   // 객체 너비의 80%
                        child.shadow.height = objectWidth * (child.shadowHeightRatio || 0.2); // 객체 너비의 20%
                    }
                }
            });
        };
    </script>
</body>
</html>